// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

// This program generates tables.go:
//	go run maketables.go | gofmt > tables.go

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"unicode/utf8"
)

// asciiSub is the ASCII substitute character, as recommended by
// http://unicode.org/reports/tr36/#Text_Comparison
const asciiSub = '\x1a'

const ascii = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f" +
	"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f" +
	` !"#$%&'()*+,-./0123456789:;<=>?` +
	`@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_` +
	"`abcdefghijklmnopqrstuvwxyz{|}~\u007f"

var encodings = []struct {
	name        string
	varName     string
	replacement byte
	mapping     string
}{
	{
		"IBM Code Page 437",
		"CodePage437",
		asciiSub,
		ascii +
			"ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒ" +
			"áíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐" +
			"└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀" +
			"αßΓπΣσµτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°•·√ⁿ²∎\u00a0",
	},
	{
		"Windows 874",
		"Windows874",
		asciiSub,
		"http://msdn.microsoft.com/en-us/goglobal/cc305142.aspx",
	},
	{
		"Windows 1250",
		"Windows1250",
		asciiSub,
		"http://msdn.microsoft.com/en-us/goglobal/cc305143.aspx",
	},
	{
		"Windows 1251",
		"Windows1251",
		asciiSub,
		"http://msdn.microsoft.com/en-us/goglobal/cc305144.aspx",
	},
	{
		"Windows 1252",
		"Windows1252",
		asciiSub,
		"http://msdn.microsoft.com/en-us/goglobal/cc305145.aspx",
	},
	{
		"Windows 1253",
		"Windows1253",
		asciiSub,
		"http://msdn.microsoft.com/en-us/goglobal/cc305146.aspx",
	},
	{
		"Windows 1254",
		"Windows1254",
		asciiSub,
		"http://msdn.microsoft.com/en-us/goglobal/cc305147.aspx",
	},
	{
		"Windows 1255",
		"Windows1255",
		asciiSub,
		"http://msdn.microsoft.com/en-us/goglobal/cc305148.aspx",
	},
	{
		"Windows 1256",
		"Windows1256",
		asciiSub,
		"http://msdn.microsoft.com/en-us/goglobal/cc305149.aspx",
	},
	{
		"Windows 1257",
		"Windows1257",
		asciiSub,
		"http://msdn.microsoft.com/en-us/goglobal/cc305150.aspx",
	},
	{
		"Windows 1258",
		"Windows1258",
		asciiSub,
		"http://msdn.microsoft.com/en-us/goglobal/cc305151.aspx",
	},
}

func getWindows(url string) string {
	res, err := http.Get(url)
	if err != nil {
		log.Fatalf("%q: Get: %v", url, err)
	}
	defer res.Body.Close()
	b, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Fatalf("%q: ReadAll: %v", url, err)
	}
	i := bytes.Index(b, []byte(`<div id="main"`))
	if i < 0 {
		log.Fatalf("%q: couldn't find main div", url)
	}
	s := string(b[i:])
	n, mapping := 0, make([]rune, 256)
	for i := range mapping {
		mapping[i] = '\ufffd'
	}
	re := regexp.MustCompile(`([0-9A-F][0-9A-F]) = U\+([0-9A-F][0-9A-F][0-9A-F][0-9A-F])`)
	for _, m := range re.FindAllStringSubmatch(s, -1) {
		n++
		x, _ := strconv.ParseInt(m[1], 16, 64)
		y, _ := strconv.ParseInt(m[2], 16, 64)
		mapping[x] = rune(y)
	}
	if n < 128 {
		log.Fatalf("%q: couldn't find enough mappings", url)
	}
	return string(mapping)
}

func main() {
	buf := make([]byte, 8)
	fmt.Printf("// generated by go run maketables.go; DO NOT EDIT\n\n")
	fmt.Printf("package charmap\n\n")
	fmt.Printf("import \"code.google.com/p/go.text/encoding\"\n\n")
	for _, e := range encodings {
		if strings.HasPrefix(e.mapping, "http://msdn.microsoft.com/") {
			e.mapping = getWindows(e.mapping)
		}

		asciiSuperset, low := strings.HasPrefix(e.mapping, ascii), 0x00
		if asciiSuperset {
			low = 0x80
		}
		lowerVarName := strings.ToLower(e.varName[:1]) + e.varName[1:]
		fmt.Printf("// %s is the %s encoding.\n", e.varName, e.name)
		fmt.Printf("var %s encoding.Encoding = &%s\n\nvar %s = charmap{\nname: %q,\n",
			e.varName, lowerVarName, lowerVarName, e.name)
		fmt.Printf("asciiSuperset: %t,\n", asciiSuperset)
		fmt.Printf("low: 0x%02x,\n", low)
		fmt.Printf("replacement: 0x%02x,\n", e.replacement)

		fmt.Printf("decode: [256]utf8Enc{\n")
		i, backMapping := 0, map[rune]byte{}
		for _, c := range e.mapping {
			if _, ok := backMapping[c]; !ok {
				backMapping[c] = byte(i)
			}
			for j := range buf {
				buf[j] = 0
			}
			n := utf8.EncodeRune(buf, c)
			if n > 3 {
				panic(fmt.Sprintf("rune %q (%U) is too long", c, c))
			}
			fmt.Printf("{%d,[3]byte{0x%02x,0x%02x,0x%02x}},", n, buf[0], buf[1], buf[2])
			if i%2 == 1 {
				fmt.Printf("\n")
			}
			i++
		}
		fmt.Printf("},\n")

		fmt.Printf("encode: [256]uint32{\n")
		encode := make([]uint32, 0, 256)
		for c, i := range backMapping {
			encode = append(encode, uint32(i)<<24|uint32(c))
		}
		sort.Sort(byRune(encode))
		for len(encode) < cap(encode) {
			encode = append(encode, encode[len(encode)-1])
		}
		for i, enc := range encode {
			fmt.Printf("0x%08x,", enc)
			if i%8 == 7 {
				fmt.Printf("\n")
			}
		}
		fmt.Printf("},\n}\n")
	}
}

type byRune []uint32

func (b byRune) Len() int           { return len(b) }
func (b byRune) Less(i, j int) bool { return b[i]&0xffffff < b[j]&0xffffff }
func (b byRune) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }
